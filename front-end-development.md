# Front End Development

## DOM  

我们需要知道，一个纯静态页面可以仅仅由 HTMl 和 CSS 样式表组成，如果你不需要发生交互的话。HTML 提供的标签有一些基础的功能，比如说 a 标签点击之后可以跳转其他页面，input 可以允许输入一些内容，button 是一个按钮，select 可以提供一些选项, video 直接可以播放视频音频。但是这些只是页面单方面提供的功能，如果不使用 JavaScript 的话，你完全不知道用户点击了哪些按钮，输入了什么内容。

html 本身是超文本标记语言，JavaScript 是一种动态解释语言。那么我们怎么使用 JavaScript 语言去改变 web页面中的标签和内容呢。这就需要 DOM，Document Object Model，就是文档对象模型。DOM是web 页面的完全的面向对象表述，它将文档解析为一个由节点和对象组成的结构集合，包含很多属性和方法。换句话说，DOM 是HTML文档的编程接口，它提供了一系列的方法，让你可以通过 JavaScript 来操作 web 页面。

DOM本身并不是一个编程语言，而是提供了一个标准，每个浏览器有自己的实现。它包括了一系列方法，在浏览器中，这些方法可以通过 window 或者 document 对象来调用。

在浏览器里面，一个 web 页面就相当于 DOM+JavaScript。可能大家对这里有疑问，为什么不是 html+DOM+JavaScript 呢，因为浏览器把 html 解析为了一个 DOM 树，这些 html 标签全部转换为了 DOM 树的节点，在文档中的每个元素都是DOM的一部分。所以 DOM其实包含了整个文档对象，包含了html, 和操作这些对象的 API。DOM是相对比较独立的。

<!--more-->

## 原生操作 DOM 的几个常用的方法 

```
document.getElementById(id)			 //根据id获取元素
document.getElementsByTagName(name)  //根据标签获取元素
document.createElement(name)		 //创建元素
parentNode.appendChild(node)	     //插入节点
element.innerHTML				     //插入 html
element.addEventListener()			 //增加监听
window.onload					     //页面加载完毕
```

## 渲染树和重绘 

浏览器把HTML源代码解析，并且创建一个DOM树，每个HTML标签在这个树上都有一个对应的节点，标签中的文本也有一个相应的文本节点。然后浏览器解析CSS代码，创建一个渲染树，然后在屏幕上绘制渲染树节点。

渲染树类似DOM树，但是并不是一一对应的。渲染树基于样式，如果 display:none 属性来隐藏一个div，那么它不会被呈现在渲染树中。

浏览器的绘制其实都是根据渲染树来绘制的，每一次元素有变化，无论是样式或内容，都会导致一次重排或重绘。节点尺寸重新计算要重排，样式改变要重绘。重排和重绘的开销很大，频繁的触发会造成页面性能严重下降。

## jQuery 和 Bootstrap 

## jQuery  

jQuery的出现极大地简化了 JavaScript 编程。jQuery 流行的原因主要是有三点。

第一消除浏览器的差异，我们在上面说到，不同的浏览器对于 DOM 有自己的实现，从这里开始就出现了浏览器的兼容问题，因为不同浏览器实现的不一样，所以它提供的 api 就不一样。比如要绑定一个事件，ie 中需要使用 attachEvent 方法，非 ie 中普遍使用 addEventListener 方法。如果不使用 jQuery ，你就需要自己写很多的腻子脚本，把所有类型的方法都写上，然后去判断浏览器存在哪个方法就用哪个方法。jQuery 把存在兼容性差异的都封装了起来使用统一的方法，那么当然就非常的方便。

第二就是简化代码，比如说简化 ajax 的请求，原生的 ajax 请求比较麻烦，写的东西比较多，但是jQuery就很简单。操作DOM的方法也变得很简单：用$代替了上面的api，$('#id') 替代了 document.getElementById('id')

第三就是轻松实现动画、修改CSS等各种操作。使用原生的方法写动画需要的内容非常的多，你需要一直去控制元素改变它的坐标，很麻烦。那么 jQuery 封装了很多常用的动画方法，比如显示隐藏，淡入淡出这种。同时方便你修改 css。

## Bootstrap  

Bootstrap 是 2011 年 twitter 开源的一个产品。为什么要把 jQuery/Bootstrap 放一起呢， 因为 Bootstrap 动画和插件要依赖 jQuery。它是一个前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。它包括响应式栅格系统，方便布局，内置了大量的组件，导航、按钮、输入框、菜单等等，让你可以快速搭建页面。你只需要写好 html 文件，套上指定的类名，就可以很快的做出效果不错的页面。当然，这个只是说你没有很强的 UI 限制的情况，实际情况下，还是需要自己来实现设计师给出的视觉效果的。

## jQuery chain 和 操作 DOM、动画

jQuery chain 是一个比较有意思的概念，呢就是说每一次的 jQuery 操作执行完毕之后都会返回这个 jQuery 对象，那么你可以继续对它进行修改，这样的话针对元素做很多个操作就会非常的简单。这里用例子来对比说明一下

- 移动元素 moveElement， 

	```
	$("#preview").mouseout(function(){
		$("#preview").animate({left:'-600px'});
	});
	```

- 发起 ajax 请求，submitFormWithAjax

## jQuery 页面开发

尽管现在有很多的前端框架，但是如果要开始学习前端的话，还是首先从 DOM 开始，原生的操作虽然很复杂，但是也需要。jQuery 还是应该仔细学习一下，它非常简单，适用面也特别的广，同时拥有很多的插件，能做各种各样的事情。

使用 jQuery 来开发项目，其实非常的简单，我们只要在 html 中引入一个 jQuery 就可以直接开发业务逻辑了。

在这里，我们提一下事件，jQuery 开发最重要的事情就是进行事件的绑定和事件的处理，事件呢就是我们在 web 页面上进行的各种操作，点击按钮，鼠标悬停，移入移出这样的操作。我们在特定的元素上绑定上事件处理函数，当事件触发时就提交数据，显示一些动画等等。

## React

我们首先解释几个 React 最基础的概念。
虚拟 DOM、数据驱动、组件化。通过对这几个概念的讲解，我们将会了解到，为什么，前端逐渐从 jQuery 开发一步步走向了这种前端的框架。

## 虚拟 DOM  

虚拟DOM是React的一大亮点，具有批处理和高效的Diff算法。这让我们可以无需担心性能问题而随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。

在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。

## 虚拟 DOM 的意义是什么？为什么要用这个东西呢？

如果没有 Virtual DOM，简单来说页面的该白就是直接重置元素 也就是innerHTML。这样操作，在一个大型列表所有数据都变了的情况下，还算是合理，但是，当只有一行数据发生变化时，它也需要重置所有元素，因为我们上面提到过，操作 DOM 是非常消耗性能的。这时候显然就造成了大量浪费。

比如说我们要往文档中添加一个表格，每次操作表格的一行，比较直接操作 DOM 和Virtual DOM 的重绘过程如下：

直接操作 DOM 的方式就是innerHTML: render html string + 重新创建所有 DOM 元素。

Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新。

可以看到我们使用虚拟 DOM 的时候，由于这种 diff 算法的存在，每次都是值更新了必要的 DOM元素，所以效率会高很多。

那么是不是就是说虚拟 DOM 比原生的 DOM 更快呢，并不是的。没有任何框架可以比纯手动的优化 DOM 操作更快，注意，这里指的是手动优化过的 DOM 操作。我们以上面的那个文档中表格添加一行的例子，如果我们把每次 innerHTML 的粒度划的特别的小，以行为单位，哪一行更改我就去操作哪一行，这样其实是最快的。但是为什么没有这么做，因为粒度变细，你的工作量会大大增加，可维护性也会变得很差，这是得不偿失的事情。

## 事件驱动和数据驱动 

### 事件驱动

```
构建页面：设计DOM => 生成DOM => 绑定事件
监听到事件：操作UI => 触发事件 => 响应处理 => 更新UI

构建页面：设计数据结构 => 事件绑定逻辑 => 生成DOM
监听到事件：操作UI => 触发事件 => 响应处理 => 更新数据 => 更新UI
```

我们之前说的，jQuery+Bootstrap 开发，是事件驱动的开发。通俗地说，事件驱动思维是从事件响应出发，来完成应用的设计和编程。

1. 开发静态页面。
2. 添加事件监听，包括用户输入、http请求、定时器触发等事件。
3. 针对不同事件，编写不同的处理逻辑，包括获取事件状态/输入、计算并更新状态等。
4. 重新渲染页面。

### 数据驱动

再说说数据驱动，什么是数据呢，数据其实是一种抽象，我们可以把一个页面抽象为不同的数据块。

就是说，在事件驱动开发里，我们渲染页面，然后绑定事件，用户进行了一些操作触发了事件处理函数，然后处理函数去操作了页面的 DOM，然后就发生了页面的更新。

但是在数据驱动开发里就不是这样了，我们首先定一些数据结构，然后根据这些数据渲染出页面，然后还是在页面的元素上面绑定一些事件，然后我们进行一些操作。不同的是，我们在事件处理函数中不是直接去操作 DOM，而是去改变页面的数据，数据的改变会导致页面内容的改变。

简单的理解，一个页面的渲染函数就是一个基于 state 和 props 的函数，state 是自己的数据，props 是外面来的数据，他们改变就重新渲染一遍。页面的任何修改和变动其实都是去改变 state，每个固定的 state 都会固定地对应一个页面状态。所以这个数据驱动的开发，这样的形式大大简化了前端的开发。

因为事件驱动开发，当你页面进行了很多很多的操作之后，页面可能会变成比较混乱的一个状态没法维护，然后操作的联动也会非常的难以处理。数据驱动就会好很多，我们只要维护好数据就可以了，因为每个数据会对应一种页面状态。

但是也不是说这样就高枕无忧了，React 也不是完美的，大型应用会带来很多规模上的复杂度，比如跨组件通信，多组件共享状态，多人协作的可维护性，大量嵌套组件的性能问题... 等等。这些东西如何处理，一步步产生了今天的各种设计模式。像 Flux/Redux 等等，他们其实比较繁琐，本质上是针对大型应用的复杂度所作出的权衡：用繁琐一些的 API，换长线的可维护性。

## 组件化 

页面上的每个独立的可视或者可交互区域视为一个组件;每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护;每个组件相对独立，页面只不过是组件的容器，组件自由组合形成功能完整的界面;当不需要某个组件，或者想要替换组件时，可以整个目录删除或者替换。

组件化其实并不是 React 所特有的，从最开始的时候前端工程就一直在组件化上面探索，主要是因为前端页面可复用的东西非常的多，你就不可避免地会把一些模块或者功能抽离出来做成公共组件。组件化可以帮助我们解决前端结构的复用性问题，整个页面可以由这样的不同的组件组合、嵌套构成。

一个组件有自己的显示形态，包含 HTML 结构和内容，组件的显示形态和行为可以由数据状态（state）和配置参数（props）共同决定。数据状态和配置参数的改变都会影响到这个组件的显示形态。

当数据变化的时候，组件的显示需要更新。所以组件化的模式能提供一种高效的方式自动化地帮助我们更新页面，那也就可以大大地降低我们代码的复杂度，带来更好的可维护性。

以 ant 为栗子，看一看以组件库都可以做哪些事情
https://preview.pro.ant.design/#/result/success

## 前端工具 

## npm 是什么 

npm（全称 Node Package Manager，即“node包管理器”）是Node.js默认的、以JavaScript编写的软件包管理系统。npm 是Node 的模块管理器，功能非常的强大，目前包含超过40W个模块，这个也是前端必须了解的模块系统，基本前端工程涉及到的所有的工具，express、webpack、gulp、less、等等都可以通过它来安装。这个也方便了我们的项目管理。

## webpack

Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、 LESS 等。

## 为什么页面需要打包

一个简单页面是由 HTML + CSS + JS 构成的。但是上面也说道，随着业务的发展，越来越多的组件，库被抽离了出来，那么在构建一个大型页面时就会需要引入很多的文件，同时存在复杂的依赖关系，如果上线这些页面把所有这些依赖也一起上线，那么就会变得难以管理。打包工具的出现，可以让你把所有的引用全部都集中到一个文件里，也就是说不管你引用了多少东西，打包完毕之后，只有一个 JS 文件，上线起来就会非常方便。另外，它还可以对文件进行压缩混淆之类的工作。

## gulp

gulp 的话，是一个自动化的构建工具，我们上面已经有了打包工具，开发完毕之后直接一打包就可以上线了。但依然存在不够智能的情况，

1. 比如说我们想把以前打包的文件删除后，再去打包新的文件，那可能我得把那个文件夹手动删除。使用 gulp 的话，gulp clean 就可以了。

2. 打包完毕之后，我想上传到某个服务器上，那我还手动需要打开 terminal 去scp。使用 gulp 的话，gulp scp 就可以了。

3. 测试环境和正式环境的代码一般是不一样的，只使用 webpack 的话，想区分两种打包可能你要去修改配置文件，使用 gulp 可以直接通过两个命令区分。

4. 我们页面特别多了以后，打包速度就会变得很慢，可能打包所有的文件一次需要1分钟，那么有时候我们可能只是修改了一个页面，我就打这个页面就可以了，这个也可以用 gulp 来做。

5. 在这样的工程化开发中，我们每次创建页面的话，可能要好几个文件，写上固定的内容，这个也可通过 gulp 来一键创建。

6. 另外给打包文件加版本号，替换文件的 cdn 引用等等。

7. 就是说，所有需要你重复做的事情，其实都可以通过 gulp 来实现自动化。
